# P5.3 - Informe RA3 sobre el despliegue (WildFly contenedor + Gradle)

## Preguntas

### a) Componentes y funcionamiento de los servicios del servidor

1. **Explica qué componentes/servicios intervienen en tu despliegue de P5.2 y qué papel tiene cada uno (como mínimo: contenedor Docker, WildFly, aplicación WAR,puertos 8080/9990 y endpoint REST). Ten en cuenta el punto c) sobre el servidor web frontal.**

    - **WildFly**: Es un servidor de aplicaciones que provee el entorno de ejecución Jakarta EE 10. Gestiona el ciclo de vida de los Servlets, inyección de dependencias y la API REST (Jakarta REST). Internamente tiene un servidor web (Undertow) que escucha en el puerto 8080.
    - **Contenedor WildFly** (imagen: "quay.io/wildfly/wildfly:latest"): Servicio aislado con Docker que ejecuta el servidor de aplicaciones.
    - **Aplicación WAR**: Paquete de la aplicación que contiene las clases, la interfaz mediante su index.html. 
    - **Puertos utilizados (mapeados al host)**:
        - 8080: Tráfico HTTP de la aplicación.
        - 9990: Consola de administración de WildFly.
    - **API REST** CRUD de tareas, tiene estos endpoints: 
        - `GET /app/api/tasks`
        - `GET /app/api/tasks/{id}`
        - `POST /app/api/tasks`
        - `PUT /app/api/tasks/{id}`
        - `DELETE /app/api/tasks/{id}`

2. **Describe el flujo de una petición desde el cliente hasta tu endpoint.**

El cliente realiza una petición HTTP a la URL "http://localhost:8080/app/api/tasks", el tráfico llega inicialmente al puerto 8080 del host, donde Docker actúa como intermediario redirigiendo el paquete de red hacia el puerto 8080 interno del contenedor WildFly. Una vez dentro del contenedor, Undertow intercepta la solicitud y basándose en la configuración del archivo jboss-web.xml incluido en el WAR identifica el contexto raíz /app para enrutar el tráfico hacia el despliegue específico de la aplicación. Después, el framework Jakarta REST analiza la ruta restante, ejecuta el endpoint elegido y devuelve la respuesta en formato JSON al cliente.

#### Evidencias

- `docker ps` mostrando el contenedor y los puertos publicados.

![Evidencia](./img/1-contenedor-wildfly-activo.png)

- `docker logs -f wildfly` mostrando el despliegue y el acceso.

    - Logs iniciales del contenedor
        ![Evidencia](./img/2-logs-contenedor-wildfly.png)

    - Logs al realizar el despliegue del WAR
        ![Evidencia](./img/10-despliegue-WAR.png)

- Respuesta del endpoint (`curl`).

![Evidencia de las respuestas del endpoint](./img/11-curl-tareas.png)

![Evidencia de las respuestas del endpoint 2](./img/13-curl-delete-tarea.png)


### b) Archivos principales de configuración y bibliotecas compartidas

1. **Identifica dentro de WildFly (en el contenedor) el/los archivo(s) de configuración principal(es) que gobiernan el servidor y señala.**

	- Donde están: Los archivos de configuración principales de se encuentran en la carpeta `/opt/jboss/wildfly/standalone/configuration/`

    ![Extracción archivo standalone](./img/6-extraccion-archivo-standalone.png)

    ![Archivos de configuración](./img/17-archivos-config.png)
    
    - Qué tipo de ajustes podrías tocar ahí para tu despliegue: Se puede cambiar los puertos que se utilizan, configurar datasource pa utilizar una base de datos diferente o configurar el nivel de detalle de los logs.

    

2. **Explica qué dependencias de tu proyecto se consideran “provided” porque el servidor ya las incluye, y qué ventaja tiene esto.**

    Solamente compileOnly, indica que la librería solo se usa para compilar. Esto hace que no empaquete en el WAR, reduciendo el tamaño del archivo y evitando errores por conflictos.
    
    ```kotlin
        dependencies {
            compileOnly("jakarta.platform:jakarta.jakartaee-api:10.0.0")
        }
    ```

    ![Build gradle](./img/7-config-build-gradle.png)


### c) Cooperación con el servidor web (proxy / reverse proxy) y https

1. **Plantea una configuración de reverse proxy para tu despliegue de P5.2 que publique la API bajo una ruta clara (por ejemplo /api/) y no exponga el puerto 9990 hacia fuera. Incluye un ejemplo de configuración (fragmento) y explica qué cambia respecto a tu despliegue actual.**

    Para el despliegue solo publicaría solo el puerto 8080 porque es donde funciona la aplicación y necesita ser expuesta para que el usuario la vea y utilice. Y cerraría el puerto 9990 para que ningún usuario no deseado pueda acceder a la consola de administración.

    La configuración del proxy inverso utilizaría nginx con esta configuración:
    ```
    server {
        listen 80;
        server_name app-tasks.com;

        location /api/ {
            proxy_pass http://wildfly:8080/app/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        location /console {
            deny all;
        }
    }
    ```

    De esta manera el servidor escucha en el puerto 8080, redirigiría el tráfico de la API a WildFly. Además para no exponer el puerto 9990 se puedo denegar todo el tráfico a esa ruta con "deny all". Ahora, en el comando docker run no haría falta mapear los puertos.

2. **Realiza una configuración de TLS (HTTPS) en el servidor web frontal y explica qué ventajas aporta esto. ¿Cambiaría algo en tu aplicación o en la configuración de WildFly?**

    Respecto a la configuración anterior sin TLS, el cambio principal es que ahora nginx escucha en el puerto 443 con SSL habilitado en lugar del puerto 80 sin cifrado. Se han añadido los certificados SSL y las directivas de protocolo TLS para establecer una conexión segura. También se incluye un segundo bloque server que escucha en el puerto 80 y redirige automáticamente todo el tráfico HTTP a HTTPS mediante un código 301. Esto garantiza que todas las conexiones sean seguras incluso si el usuario intenta acceder por HTTP. Además, se ha añadido la cabecera X-Forwarded-Proto en el proxy_pass para que WildFly pueda identificar que la conexión original del cliente era HTTPS, es importante si la aplicación necesita generar enlaces absolutos.

    Configuración:
    ```
    server {
        listen 443 ssl;
        server_name localhost;

        ssl_certificate /etc/nginx/certificados/certificado.crt;
        ssl_certificate_key /etc/nginx/certificados/certificado.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;

        location /api/ {
            proxy_pass http://wildfly:8080/app/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /console {
            deny all;
        }
    }

    # Redirige HTTP a HTTPS
    server {
        listen 80;
        server_name localhost;
        return 301 https://$server_name$request_uri;
    }
    ```

    Configurar TLS en nginx permite el cifrado de extremo a extremo entre el cliente y el proxy. Esto mejorar la seguridad general de la aplicación, protegiendo los datos. También aumentaría la confianza de los usuarios al ser seguro y cumpliría los estándares actuales. En la aplicación no hay ningún cambio aparente, pero habría que configurar para poder leer cabeceras X-Forwarded-Proto si se generan enlaces absolutos.


### d) Mecanismos de seguridad del servidor de aplicaciones

1. **Indica qué medidas de seguridad aplicaste en P5.2**

    Usé un usuario de gestión mediante `add-user.sh`. Además al utilizar Wildfly, mediante el contenedor Docker, aumenta la seguridad en mi máquina local al tener el entorno aislado.

2. **Indica qué medidas añadirías para producción (mínimo 4), justificando cada una.**

	1. Deshabilitaría la exposición pública del puerto 9990 para que no se pueda acceder públicamente a la consola de administración a usuarios no deseados.
    2. Para la gestión de secretos, usaría variables de entorno en un archivo .env o github secrets para no pasar datos sensibles.
    3. Habilitaría HTTPS para cifrar todo el tráfico y aumentar la seguridad.
    4. Logs más robustos y específicos para monitorización de seguridad, esto permitiría poder encontrar fallos de seguridad lo más pronto posible para evitar daños graves.
    5. Implementaría un proxy inverso para no exponer Wildfly directamente y proteger más la aplicación.
    6. Rate limiting para controlar múltiples peticiones consecutivas y evitar posibles DDos,

#### Evidencias

- Captura de puertos expuestos.

    ![Puertos expuestos](./img/1-contenedor-wildfly-activo.png)

- Captura de que la consola solo es accesible internamente (solo es accesible internamente si no se usa el parámetro `-bmanagement 0.0.0.0`).

    ![Consola solamente internamente](./img/18-consola-internamente.png)


### e) Componentes web del servidor de aplicaciones

1. **Explica cómo se engancha la aplicación REST a WildFly en P5.2:**

	- Qué es el WAR y qué contiene a alto nivel.  
        Es una archivo comprimido que tiene los archivos necesarios para desplegar la aplicación. Contiene las clases en "WEB-INF/classes" y también, contiene index.html, web.xml y jboss-web.xml.
    - Qué significa el contexto/ruta base de la app.  
        Es la raíz que va a tener la url, se configura en `src/main/webapp/WEB-INF/jboss-web.xml` donde se define la ruta que va a seguir (/app):
        ```xml
        <?xml version="1.0" encoding="UTF-8"?>
        <jboss-web>
            <context-root>/app</context-root>
        </jboss-web>
        ```
        
        ![Contexto personalizado configurado](./img/9-contexto-personalizado-configurado.png)
        
    - Qué parte del servidor se encarga de servir la API (contenedor web)   
        Dentro de Wildfly, se encarga el subsistema Undertow actuando de contenedor web. Escucha en el puerto 8080 y lee los archivos XML al desplegar y también, inicia los endpoints.

2. **Incluye una URL real de tu práctica y desglósala (host, puerto, contexto, ruta del recurso).**

    URL --> `http://localhost:8080/app/api/tasks`

    - **Protocolo**: `http` (sin cifrado)
    - **Host**: `localhost`.
    - **Puerto**: `8080` (expuesto por Docker).
    - **Contexto base**: `/app` (definido en `jboss-web.xml`).
    - **Ruta Jakarta REST**: `/api` (definido con @ApplicationPath("/api") en TasksApplication.java).
    - **Recurso**: `/tasks` (definido con @Path("/tasks") en TaskResource.java).

#### Evidencias

- URLs probadas en navegador/curl.  
    Ejemplo con curl:
    ![Endpoints probados](./img/11-curl-tareas.png)
- Log del servidor mostrando el acceso. Los logs que aparecen son las operaciones que va realizando y en el log aparece: donde y que está haciendo.
    ![Logs](./img/16.logs-acceso.png)

### f) Parámetros necesarios para el despliegue

1. **Enumera y justifica los parámetros que fueron necesarios en tu despliegue de P5.2 (mínimo 5).**
    Comando --> `docker run -d --name wildfly -p 8080:8080 -p 9990:9990 quay.io/wildfly/wildfly:latest /opt/jboss/wildfly/bin/standalone.sh -b 0.0.0.0 -bmanagement 0.0.0.0`


    1. `-d` (detached mode): Ejecuta el contenedor en segundo plano.
    2. **`--name wildfly`:** Asigna el nombre "wildfly" al contenedor.
    3. `-p 8080:8080` y `-p 9990:9990`: Mapeo de puertos (Host:Contenedor).
    4. `quay.io/wildfly/wildfly:latest`: Indica la imagen a utilizar.
    5.  `/opt/jboss/wildfly/bin/standalone.sh`: Comando de inicio (lo inicia en modo standalone).
    6.  **`-b 0.0.0.0`:** Binding de la interfaz pública (aplicaciones), acepta conexiones desde cualquier dirección IP.
    7.  **`-bmanagement 0.0.0.0`:** Igual que el anterior, pero para la interfaz de gestión.

2. **Explica qué pasaría si uno de esos parámetros estuviera mal.**

    Por ejemplo si `-b 0.0.0.0` estuviera mal, WildFly arrancaría normal, pero rechazaría todas las conexiones externas. En caso de que cualquier parametro estuviera mal sintácticamente, el comando fallaría.

    ![Comando mal](./img/19-comando-mal.png)

### g) Pruebas de funcionamiento y rendimiento

1. **Describe qué pruebas funcionales hiciste en P5.2 y aporta evidencias.**

    He probado el funcionamiento mediante peticiones con curl (todos los endpoints probados de la aplicación) y navegador (utilicé el endpoint para listar las tareas):

    ![Prueba funcionamiento curl 1](./img/11-curl-tareas.png)
    ![Prueba funcionamiento curl 2](./img/13-curl-delete-tarea.png)
    ![Prueba funcionamiento navegador](./img/12-navegador-tareas.png)


2. **Ejecuta una prueba de rendimiento básica (elige una: ab (ApacheBench), hey o wrk) e incluye el comando utilizado, el endpoint probado y un breve análisis del resultado (latencia, peticiones/segundo o errores).**

    Realicé la prueba de rendimiento con wrk mediante el comando `wrk -t4 -c100 -d10s http://localhost:8080/modulename.backend-0.0.1-SNAPSHOT/app/api/tasks`.

    Resultado del análisis:
    ![Prueba rendimiento](./img/14-prueba-rendimiento-wrk.png)

    - `-t4`: Número de hilos de ejecución (4).
    - `c100`: Número de conexiones HTTP mantenidas abiertas simultáneamente (100).
    - `d10s`: Duración de la prueba (10s).
    - `http://localhost:8080/modulename.backend-0.0.1-SNAPSHOT/app/api/tasks`: Endpoint utilizado.

    **Latencia**:

    | Métrica              | Valor      |
    |----------------------|------------|
    | Promedio             | 10.45 ms   |
    | Desviación estándar  | 14.91 ms   |
    | Máxima               | 205.20 ms  |
    | ± Stdev              | 89%        |

    **Rendimiento**

    | Métrica                | Valor            |
    |------------------------|------------------|
    | Requests/sec (thread)  | 4.29k promedio   |
    | Requests/sec (global)  | 17,054.97 req/s  |
    | Requests totales       | 170,604          |
    | Transferencia          | 3.61 MB/s        |
    | Datos leídos           | 36.12 MB         |


    Durante la prueba, aparecen estos logs: 

    ![Logs prueba rendimiento](./img/15-logs-prueba-rendimiento.png)

### h) Documentación de administración y recomendaciones

**Redacta una mini-guía de administración para tu despliegue de P5.2 que incluya (Debe ser reproducible para otra persona del equipo.):**



#### 1. Cómo levantar WildFly

Primero compila la aplicación para generar el war necesario.
```bash
./gradlew clean build
```

![WAR generado](./img/8-WAR-generado.png)

Hay dos opciones para levantar la aplicación:

Levantar con docker compose (Recomendado)

```bash
docker compose up -d
```

La otra opción es utilizar solamente el contenedor de wildfly sin gestión mediante un proxy inverso:

```bash
docker run -d --name wildfly -p 8080:8080 -p 9990:9990 \
  quay.io/wildfly/wildfly:latest \
  /opt/jboss/wildfly/bin/standalone.sh -b 0.0.0.0 -bmanagement 0.0.0.0
```

Para poder ver si está funcionando correctamente puedes usar estos comandos.
```bash
docker compose ps
docker ps
```

![Contenedores activos](./img/docker-compose-ps.png)

#### 2. Cómo desplegar una nueva versión del WAR

Siempre que vayas a desplegar un nuevo WAR, debes compilar la aplicación de nuevo
```bash
./gradlew clean build
```

En caso de estar utilizando docker compose, para parar y volver a levantar los servicios utiliza estos comandos:

```bash
docker compose down
docker compose up -d --build
```

Si utilizas docker run debes copiar el WAR a la carpeta deployments
```bash
docker cp build/libs/app.war wildfly:/opt/jboss/wildfly/standalone/deployments/
```

Puedes verificar despliegue en los logs:**
```bash
docker compose logs -f wildfly | docker logs -f wildfly
```
![Logs de despliegue](./img/10-despliegue-WAR.png)

#### 3. Cómo comprobar el estado (logs y endpoint de prueba)

Para comprobar el estado de los contenedor puedes utilizar `docker ps` o `docker compose ps`.

También puedes ver los logs de un contenedor en específico utilizando uno de estos comandos:

```bash
docker compose logs -f | docker logs -f
```

**URLs de prueba para probar la app**
- API (docker compose): `https://localhost/api/tasks`
- API (docker run): `http://localhost:8080/app/api/tasks`
- Consola WildFly: `http://localhost:9990/console` (si puerto expuesto y se permite conexiones externas con el parámetro "-bmanagement 0.0.0.0")

**Acceso a la consola de administración:**

Primero debes crear un usuario administrador:

![Creación usuario administración](./img/3-creacion-usuario-administracion.png)

Luego acceder con las credenciales:

![Login consola](./img/4-login-consola.png)

![Consola web WildFly](./img/5-consola-web.png)

**Puedes probar los endpoints con estos comandos:**

**IMPORTANTE**: Debes cambiar la ruta dependiendo de si estás usando la API levantada con docker compose o con docker run. 
```bash
# Listar tareas
curl -k https://localhost/api/tasks

# Crear tarea
curl -k -X POST https://localhost/api/tasks \
  -H "Content-Type: application/json" \
  -d '{"title":"Nueva tarea","done":false}'

# Obtener tarea específica
curl -k https://localhost/api/tasks/1

# Eliminar tarea
curl -k -X DELETE https://localhost/api/tasks/1
```

![Pruebas con curl](./img/11-curl-tareas.png)

![Prueba navegador](./img/12-navegador-tareas.png)

**Puedes realizar también pruebas de rendimiento con estos comandos:**

**IMPORTANTE**: Debes cambiar la ruta dependiendo de si estás usando la API levantada con docker compose o con docker run. 
```bash
# Con wrk (4 hilos, 100 conexiones, 10 segundos)
wrk -t4 -c100 -d10s https://localhost/api/tasks

# Con ApacheBench
ab -n 1000 -c 100 https://localhost/api/tasks
```

![Prueba de rendimiento wrk](./img/14-prueba-rendimiento-wrk.png)

#### 4. Recomendaciones para evitar errores comunes

1. **Puerto ocupado**:
   
```bash
    # Ver qué contenedor usa el puerto
    docker ps
    
    # Detener y eleminar el contenedor
    docker rm -f nombreContenedor
```

2. **WAR no se encuentra**:
   ```bash
   # Verificar que existe
   ls -lh build/libs/*.war
   
   # Si no existe, compilar
   ./gradlew clean build
   ```

3. **WildFly tarda en arrancar**:
   - Espera 30-60 segundos antes de hacer peticiones
   - Busca en logs: `"WildFly Full X.X.X.Final started"`

4. **Error 404 en la API**:
   - Verifica la URL correcta: `/app/api/tasks` (no `/api/tasks`)
   - Contexto `/app` definido en `jboss-web.xml`

5. **Certificado SSL no válido**:
   - Usa `-k` en curl o utiliza en el navegador con la advertencia.
   - Genera los certificados de nuevo

**Recomendaciones de seguridad para producción:**

1. No exponer puerto 9990: Eliminar `-p 9990:9990` del comando docker run
2. Usar certificados válidos: Let's Encrypt en lugar de autofirmados
3. Variables de entorno: Usar `.env` o Github Secrets para credenciales (usa gitignore si usas .env)
4. Firewall: Configurar iptables para filtrar tráfico no deseado
5. Rate limiting: Activar en nginx para prevenir DDoS
6. Actualizaciones: Mantener imágenes al día con `docker compose pull`
7. Logs de auditoría: Activar en WildFly para monitorización

**Comandos útiles de administración:**
```bash
# Reiniciar servicios
docker compose restart

# Ver uso de recursos
docker stats

# Limpiar contenedores detenidos
docker container prune

# Ver redes Docker
docker network ls

# Inspeccionar red
docker network inspect 2526-u2-5-3-jakarta-wildfly-gradle-danielmi5_red-api-tasks

# Acceder al contenedor
docker exec -it wildfly bash
docker exec -it nginx sh
```


### i) Virtualización, nube o contenedores en el despliegue

**Realiza un despliegue haciendo uso de docker compose que auné todo. Servidor web (Nginx) + servidor de aplicaciones (WildFly) + tu aplicación REST.**

Despliegue mediante docker compose realizado (backend y frontend separado), se han generado también los certificados y se ha configurado nginx. Se orquesta un servidor web (nginx) que se comunica mediante una red privada (red-api-tasks) con wildfly.

Archivos importantes del despliegue con docker compose:
- `Dockerfile`: Imagen personalizada de WildFly
- `docker-compose.yml`: Orquestación nginx + WildFly
- `nginx.conf`: Proxy inverso con HTTPS
- `.env`: Credenciales (WILDFLY_USUARIO, WILDFLY_CONTRA)


## Documentación utilizada

- [https://docs.wildfly.org/](https://docs.wildfly.org/)
- [https://quay.io/repository/wildfly/wildfly?tab=info](https://quay.io/repository/wildfly/wildfly?tab=info)