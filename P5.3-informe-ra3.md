# P5.3 - Informe RA3 sobre el despliegue (WildFly contenedor + Gradle)

## Preguntas

### a) Componentes y funcionamiento de los servicios del servidor

1. **Explica qué componentes/servicios intervienen en tu despliegue de P5.2 y qué papel tiene cada uno (como mínimo: contenedor Docker, WildFly, aplicación WAR,puertos 8080/9990 y endpoint REST). Ten en cuenta el punto c) sobre el servidor web frontal.**

    - **WildFly**: Es un servidor de aplicaciones que provee el entorno de ejecución Jakarta EE 10. Gestiona el ciclo de vida de los Servlets, inyección de dependencias y la API REST (Jakarta REST). Internamente tiene un servidor web (Undertow) que escucha en el puerto 8080.
    - **Contenedor WildFly** (imagen: "quay.io/wildfly/wildfly:latest"): Servicio aislado con Docker que ejecuta el servidor de aplicaciones.
    - **Aplicación WAR**: Paquete de la aplicación que contiene las clases, la interfaz mediante su index.html. 
    - **Puertos utilizados (mapeados al host)**:
        - 8080: Tráfico HTTP de la aplicación.
        - 9990: Consola de administración de WildFly.
    - **API REST** CRUD de tareas, tiene estos endpoints: 
        - `GET /app/api/tasks`
        - `GET /app/api/tasks/{id}`
        - `POST /app/api/tasks`
        - `PUT /app/api/tasks/{id}`
        - `DELETE /app/api/tasks/{id}`

2. **Describe el flujo de una petición desde el cliente hasta tu endpoint.**

El cliente realiza una petición HTTP a la URL "http://localhost:8080/app/api/tasks", el tráfico llega inicialmente al puerto 8080 del host, donde Docker actúa como intermediario redirigiendo el paquete de red hacia el puerto 8080 interno del contenedor WildFly. Una vez dentro del contenedor, Undertow intercepta la solicitud y basándose en la configuración del archivo jboss-web.xml incluido en el WAR identifica el contexto raíz /app para enrutar el tráfico hacia el despliegue específico de la aplicación. Después, el framework Jakarta REST analiza la ruta restante, ejecuta el endpoint elegido y devuelve la respuesta en formato JSON al cliente.

#### Evidencias

- `docker ps` mostrando el contenedor y los puertos publicados.

![Evidencia](./img/1-contenedor-wildfly-activo.png)

- `docker logs -f wildfly` mostrando el despliegue y el acceso.

    - Logs iniciales del contenedor
        ![Evidencia](./img/2-logs-contenedor-wildfly.png)

    - Logs al realizar el despliegue del WAR
        ![Evidencia](./img/10-despliegue-WAR.png)

- Respuesta del endpoint (`curl`).

![Evidencia de las respuestas del endpoint](./img/11-curl-tareas.png)

![Evidencia de las respuestas del endpoint 2](./img/13-curl-delete-tarea.png)


### b) Archivos principales de configuración y bibliotecas compartidas

1. **Identifica dentro de WildFly (en el contenedor) el/los archivo(s) de configuración principal(es) que gobiernan el servidor y señala.**

	- Donde están: Los archivos de configuración principales de se encuentran en la carpeta `/opt/jboss/wildfly/standalone/configuration/`
    
    - Qué tipo de ajustes podrías tocar ahí para tu despliegue: Se puede cambiar los puertos que se utilizan, configurar datasource pa utilizar una base de datos diferente o configurar el nivel de detalle de los logs.

2. **Explica qué dependencias de tu proyecto se consideran “provided” porque el servidor ya las incluye, y qué ventaja tiene esto.**

    Solamente compileOnly, indica que la librería solo se usa para compilar. Esto hace que no empaquete en el WAR, reduciendo el tamaño del archivo y evitando errores por conflictos.
    
    ```kotlin
        dependencies {
            compileOnly("jakarta.platform:jakarta.jakartaee-api:10.0.0")
        }
    ```


#### Evidencias

- Captura/salida de `docker exec -it wildfly ls /opt/jboss/wildfly/standalone/configuration/`.
- Fragmento del `build.gradle.kts` donde se ve `compileOnly`.


### c) Cooperación con el servidor web (proxy / reverse proxy) y https

1. **Plantea una configuración de reverse proxy para tu despliegue de P5.2 que publique la API bajo una ruta clara (por ejemplo /api/) y no exponga el puerto 9990 hacia fuera.**

2. **Incluye un ejemplo de configuración (fragmento) y explica qué cambia respecto a tu despliegue actual.**

3. **Realiza una configuración de TLS (HTTPS) en el servidor web frontal y explica qué ventajas aporta esto. ¿Cambiaría algo en tu aplicación o en la configuración de WildFly?**

#### Evidencias

- Fragmento de `nginx.conf` o `sites-enabled`.
- Explicación de qué puertos publicarías en Docker y cuáles no.
- Como has configurado TLS (certificados, etc.) y qué ventajas aporta.


### d) Mecanismos de seguridad del servidor de aplicaciones

1. **Indica qué medidas de seguridad aplicaste en P5.2**

2. **Indica qué medidas añadirías para producción (mínimo 4), justificando cada una.**

	- Consola de administración (9990) y credenciales.
    - Exposición de puertos.
    - Gestión de secretos (usuarios/contraseñas).
    - Registro y trazabilidad (logs).

#### Evidencias

- Captura de puertos expuestos.
- Captura de que la consola solo es accesible internamente.
- Ejemplo de política de secretos.


### e) Componentes web del servidor de aplicaciones

1. **Explica cómo se engancha la aplicación REST a WildFly en P5.2:**

	- Qué es el WAR y qué contiene a alto nivel.
    - Qué significa el contexto/ruta base de la app.
    - Qué parte del servidor se encarga de servir la API (contenedor web).

2. **Incluye una URL real de tu práctica y desglósala (host, puerto, contexto, ruta del recurso).**


#### Evidencias

- URLs probadas en navegador/curl.
- Log del servidor mostrando el acceso.


### f) Parámetros necesarios para el despliegue

1. **Enumera y justifica los parámetros que fueron necesarios en tu despliegue de P5.2 (mínimo 5).**

	- Parámetros de docker run (nombre, puertos, etc.).
    - Nombre del WAR y ruta de despliegue.
    - Variables o ajustes del build (Gradle).

2. **Explica qué pasaría si uno de esos parámetros estuviera mal.**

#### Evidencias


### g) Pruebas de funcionamiento y rendimiento

1. **Describe qué pruebas funcionales hiciste en P5.2 y aporta evidencias.**

2. **Ejecuta una prueba de rendimiento básica (elige una: ab (ApacheBench), hey o wrk) e incluye el comando utilizado, el endpoint probado y un breve análisis del resultado (latencia, peticiones/segundo o errores).**

#### Evidencias

- Salida completa de `ab`/`hey`/`wrk` y análisis.
- Logs durante la prueba.

### h) Documentación de administración y recomendaciones

**Redacta una mini-guía de administración para tu despliegue de P5.2 que incluya (Debe ser reproducible para otra persona del equipo.):**

1. Cómo levantar WildFly.
2. Cómo desplegar una nueva versión del WAR.
3. Cómo comprobar el estado (logs y endpoint de prueba).
4. Recomendaciones para evitar errores comunes.


#### Evidencias

- Manual con instrucciones claras y paso a paso, acompañado de: 
- Ficheros Docker: dockerfile y compose. 
- Arquitectura de desplieuge 
- Comandos clave (docker, despliegue, pruebas). 
- URLs de prueba. 
- Acceso a logs y endpoints. 
- Pruebas de funcionamiento. 
- Pruebas de rendimiento. 
- Recomendaciones de seguridad.


### i) Virtualización, nube o contenedores en el despliegue

**Realiza un despliegue haciendo uso de docker compose que auné todo. Servidor web (Nginx) + servidor de aplicaciones (WildFly) + tu aplicación REST.**

Ten en cuenta volúmenes para logs, secretos, healthchecks y reinicio automático, limitación de recursos, redes, etc.

Una mejora adicional, sería separar frontend y backend en contenedores distintos, con comunicación entre ellos, y no exponer el backend directamente al host.

#### Evidencias


## Documentación utilizada

- [https://docs.wildfly.org/](https://docs.wildfly.org/)
- [https://quay.io/repository/wildfly/wildfly?tab=info](https://quay.io/repository/wildfly/wildfly?tab=info)